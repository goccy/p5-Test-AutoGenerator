#include "auto_test.h"

//========================<<< GLOBAL VARIABLE >>>=================================//
jmp_buf jbuf;
static TestCodeGenerator *tcg = NULL;

static char *use_list[] = {
    "use strict", "use warnings", "use FindBin::libs qw(base=lib)",
    "use FindBin::libs qw(base=inc)", "use Test::More \"no_plan\"", "use Test::MockObject",
    NULL
};
//========================= CallFlow Class API ===================================//

static void CallFlow_setReturnValue(CallFlow *cf, char *ret_value)
{
    size_t size = strlen(ret_value) + 1;
    char *str = safe_malloc(size);
    memcpy(str, ret_value, size);
    cf->ret = str;
}

static void CallFlow_free(CallFlow *cf)
{
    while (cf) {
        safe_free((char *)cf->from_stash, strlen(cf->from_stash) + 1);
        safe_free((char *)cf->from, strlen(cf->from) + 1);
        safe_free((char *)cf->to_stash, strlen(cf->to_stash) + 1);
        safe_free((char *)cf->to, strlen(cf->to) + 1);
        if (cf->ret) {
            safe_free((char *)cf->ret, strlen(cf->ret) + 1);
        }
        CallFlow *cur_cf = cf;
        cf = cf->next;
        safe_free(cur_cf, sizeof(CallFlow));
    }
}

static CallFlow *new_CallFlow(char *from_stash, char *from_subname,
                              char *to_stash, char *to_subname)
{
    CallFlow *cf = safe_malloc(sizeof(CallFlow));
    size_t from_stash_size = (from_stash) ? strlen(from_stash) + 1 : 0;
    size_t from_subname_size = (from_subname) ? strlen(from_subname) + 1 : 0;
    size_t to_stash_size = (to_stash) ? strlen(to_stash) + 1 : 0;
    size_t to_subname_size = (to_subname) ? strlen(to_subname) + 1 : 0;
    cf->from_stash = (const char *)safe_malloc(from_stash_size);
    memcpy((char *)cf->from_stash, from_stash, from_stash_size);
    cf->from = (const char *)safe_malloc(from_subname_size);
    memcpy((char *)cf->from, from_subname, from_subname_size);
    cf->to_stash = (const char *)safe_malloc(to_stash_size);
    memcpy((char *)cf->to_stash, to_stash, to_stash_size);
    cf->to = (const char *)safe_malloc(to_subname_size);
    memcpy((char *)cf->to, to_subname, to_subname_size);
    cf->setReturnValue = CallFlow_setReturnValue;
    cf->free = CallFlow_free;
    return cf;
}

//========================= MethodList Class API =================================//
static Method *mtd_lists[MAX_METHOD_NUM];
static int mtd_idx = 0;
static Method *MethodList_getMatchedMethod(Method **mtd_list, const char *mtd_name)
{
    Method *ret = NULL;
    size_t mtd_name_size = strlen(mtd_name) + 1;
    int i = 0;
    for (i = 0; i < mtd_idx; i++) {
        const char *cmp_name = mtd_list[i]->name;
        size_t cmp_name_size = strlen(cmp_name) + 1;
        if (mtd_name_size == cmp_name_size &&
            !strncmp(mtd_name, cmp_name, mtd_name_size)) {
            ret = mtd_list[i];
            break;
        }
    }
    return ret;
}

static void MethodList_addMethod(Method **mtd_list, Method *mtd)
{
    mtd_list[mtd_idx] = mtd;
    mtd_idx++;
    if (mtd_idx > MAX_METHOD_NUM) {
        fprintf(stderr, "ERROR!!: mtd num > %d\n", MAX_METHOD_NUM);
    }
}

//========================= Method Class API =================================//
static void Method_addCallFlow(Method *mtd, CallFlow *cf)
{
    if (!mtd->cfs) {
        mtd->cfs = cf;
    } else {
        CallFlow *cfs = mtd->cfs;
        for (; cfs->next; cfs = cfs->next) {}
        cfs->next = cf;
    }
}

static void Method_setArgs(Method *mtd, char *args)
{
    mtd->args = args;
}

static bool Method_existsCallFlow(Method *mtd, CallFlow *cf)
{
    bool ret = false;
    CallFlow *cfs = mtd->cfs;
    for (; cfs; cfs = cfs->next) {
        if (match(cfs->from_stash, cf->from_stash) &&
            match(cfs->from, cf->from) &&
            match(cfs->to_stash, cf->to_stash) &&
            match(cfs->to, cf->to)) {
            ret = true;
            break;
        }
    }
    return ret;
}

static void Method_free(Method *mtd)
{
    while (mtd) {
        safe_free((char *)mtd->name, strlen(mtd->name) + 1);
        if (mtd->args) safe_free((char *)mtd->args, strlen(mtd->args) + 1);
        if (mtd->cfs) {
            mtd->cfs->free(mtd->cfs);
        }
        Method *cur_mtd = mtd;
        mtd = mtd->next;
        safe_free(cur_mtd, sizeof(Method));
    }
}

static Method *new_Method(const char *name, const char *stash, const char *subname)
{
    Method *mtd = safe_malloc(sizeof(Method));
    mtd->name = name;
    mtd->stash = stash;
    mtd->subname = subname;
    mtd->ret = NULL;
    mtd->addCallFlow = Method_addCallFlow;
    mtd->existsCallFlow = Method_existsCallFlow;
    mtd->setArgs = Method_setArgs;
    mtd->free = Method_free;
    return mtd;
}

//========================= Package Class API =================================//
static void Package_addMethod(Package *pkg, Method *mtd)
{
    if (!mtd) {
        fprintf(stderr, "ERROR!!: Method is NULL\n");
        exit(EXIT_FAILURE);
    }
    if (!pkg->mtds) {
        pkg->mtds = mtd;
    } else {
        Method *mtds = pkg->mtds;
        for (; mtds->next; mtds = mtds->next) {}
        mtds->next = mtd;
    }
}

static bool Package_existsLibrary(Package *pkg, const char *path)
{
    bool ret = false;
    int i = 0;
    for (; i < pkg->lib_num; i++) {
        if (match(pkg->lib_paths[i], path)) {
            ret = true;
            break;
        }
    }
    return ret;
}

static void Package_addLibraryPath(Package *pkg, const char *path)
{
    pkg->lib_paths = (const char **)realloc(pkg->lib_paths, sizeof(char *) * (pkg->lib_num + 1));
    pkg->lib_paths[pkg->lib_num] = path;
    pkg->lib_num++;
}

static void Package_free(Package *pkg)
{
    while (pkg) {
        if (pkg->mtds) {
            pkg->mtds->free(pkg->mtds);
        }
        safe_free(pkg->lib_paths, sizeof(char *) * pkg->lib_num);
        Package *cur_pkg = pkg;
        pkg = pkg->next;
        safe_free(cur_pkg, sizeof(Package));
    }
}

static Package *new_Package(const char *pkg_name)
{
    Package *pkg = safe_malloc(sizeof(Package));
    pkg->name = pkg_name;
    pkg->addMethod = Package_addMethod;
    pkg->existsLibrary = Package_existsLibrary;
    pkg->addLibraryPath = Package_addLibraryPath;
    pkg->free = Package_free;
    return pkg;
}

//========================= Library Class API =================================//
//static Library *new_Library(char *path__)
//{
//    char *path_ = safe_malloc(strlen(path__) + 1);
//    strcpy(path_, path__);
//    char *path = safe_malloc(strlen(path_) + 1);
//    strcpy(path, path_);
//    char *tk = strtok(path_, "::");
//    char *name = NULL;
//    while (tk != NULL) {
//        tk = strtok(NULL, "::");
//        if (tk != NULL) name = tk;
//    }
//    Library *lib = safe_malloc(sizeof(Library));
//    lib->path = path;
//    lib->name = (name) ? name : path;
//    return lib;
//}

//========================= TestCodeGenerator Class API =================================//
static Package *TestCodeGenerator_getMatchedPackage(TestCodeGenerator *tcg, const char *pkg_name)
{
    Package *ret = NULL;
    Package *pkg_search_ptr = tcg->pkgs;
    size_t pkg_name_size = strlen(pkg_name) + 1;
    for (; pkg_search_ptr; pkg_search_ptr = pkg_search_ptr->next) {
        const char *cmp_name = pkg_search_ptr->name;
        size_t cmp_name_size = strlen(cmp_name) + 1;
        if (pkg_name_size == cmp_name_size &&
            !strncmp(pkg_name, cmp_name, pkg_name_size)) {
            ret = pkg_search_ptr;
            break;
        }
    }
    return ret;
}

static void TestCodeGenerator_addPackage(TestCodeGenerator *tcg, Package *pkg)
{
    if (!tcg->pkgs) {
        tcg->pkgs = pkg;
    } else {
        Package *pkgs = tcg->pkgs;
        for (; pkgs->next; pkgs = pkgs->next) {}
        pkgs->next = pkg;
    }
}

static void TestCodeGenerator_gen(TestCodeGenerator *tcg)
{
    char filename[MAX_FILE_NAME_SIZE] = {0};
    Package *pkgs = tcg->pkgs;
    CHANGE_COLOR(GREEN);
    fprintf(stderr, "AutoTest gen : START\n");
    CHANGE_COLOR(WHITE);
    for (; pkgs; pkgs = pkgs->next) {
        if (match(pkgs->name, "main")) continue;
        snprintf(filename, MAX_FILE_NAME_SIZE, "/tmp/%s.t", pkgs->name);
        FILE *fp;
        if ((fp = fopen(filename, "w")) == NULL) {
            fprintf(stderr, "ERROR!!: file open error[%s], (%s)\n", filename, strerror(errno));
            exit(EXIT_FAILURE);
        }
        fprintf(stderr, "AutoTest gen : [%s]\n", filename);
        int i = 0;
        for (i = 0; use_list[i] != NULL; i++) {
            fprintf(fp, "%s;\n", use_list[i]);
        }
        fprintf(fp, "\n");
        fprintf(fp, "use_ok('%s');\n", pkgs->name);
        i = 1;
        Method *mtds = pkgs->mtds;
        for (; mtds; mtds = mtds->next) {
            //fprintf(stderr, "mtds->name = [%s]\n", mtds->name);
            if (mtds->subname && match(mtds->subname, "main")) {
                i++; continue;
            }
            fprintf(fp, "sub test_%03d_%s {\n", i, mtds->subname);
            bool comment_out_flag = false;
            CallFlow *cfs = mtds->cfs;
            for (; cfs; cfs = cfs->next) {
                comment_out_flag = false;
                if (match(cfs->to_stash, mtds->stash)) continue;
                if (!cfs->ret || cfs->is_xs) comment_out_flag = true;
                write_space(fp, 4, comment_out_flag);
                fprintf(fp, "Test::MockObject->fake_module(\"%s\",\n", cfs->to_stash);
                write_space(fp, 8, comment_out_flag);
                fprintf(fp, "%s => sub {\n", cfs->to);
                write_space(fp, 12, comment_out_flag);
                if (cfs->is_xs) {
                    fprintf(fp, "%s\n", XS_ERROR_TEXT);
                } else if (!cfs->ret) {
                    fprintf(fp, "%s\n", TRACE_ERROR_TEXT);
                } else {
                    fprintf(fp, "%s;\n", cfs->ret);
                }
                write_space(fp, 8, comment_out_flag);
                fprintf(fp, "});\n");
            }
            comment_out_flag = false;
            if (mtds->args_error) comment_out_flag = true;
            if (mtds->stash && match(mtds->stash, "main")) {
                write_space(fp, 4, comment_out_flag);
                if (mtds->ret_type == TYPE_List) {
                    fprintf(fp, "my @ret = %s(", mtds->subname);
                } else if (!mtds->ret) {
                    write_space(fp, 4, comment_out_flag);
                    fprintf(fp, "%s(", mtds->subname);
                } else {
                    fprintf(fp, "my $ret = %s(", mtds->subname);
                }
            } else {
                write_space(fp, 4, comment_out_flag);
                if (mtds->ret_type == TYPE_List) {
                    fprintf(fp, "my @ret = %s::%s(", mtds->stash, mtds->subname);
                } else if (!mtds->ret) {
                    fprintf(fp, "%s::%s(", mtds->stash, mtds->subname);
                } else {
                    fprintf(fp, "my $ret = %s::%s(", mtds->stash, mtds->subname);
                }
            }
            if (mtds->args) {
                fprintf(fp, "%s", mtds->args);
            }
            if (mtds->args_error) {
                fprintf(fp, "); %s\n", TRACE_ERROR_TEXT);
            } else {
                fprintf(fp, ");\n");
            }
            if (mtds->ret) {
                switch (mtds->ret_type) {
                case TYPE_Int: case TYPE_Double:
                    write_space(fp, 4, comment_out_flag);
                    fprintf(fp, "ok($ret == %s, \"%s\");\n", mtds->ret, mtds->name);
                    break;
                case TYPE_PtrInt: case TYPE_PtrDouble:
                    write_space(fp, 4, comment_out_flag);
                    if (find(mtds->ret, '\"')) {
                        fprintf(fp, "ok($ret eq %s, \"%s\");\n", mtds->ret, mtds->name);
                    } else {
                        fprintf(fp, "ok($ret == %s, \"%s\");\n", mtds->ret, mtds->name);
                    }
                    break;
                case TYPE_String:
                    write_space(fp, 4, comment_out_flag);
                    fprintf(fp, "is($ret, %s, \"%s\");\n", mtds->ret, mtds->name);
                    break;
                case TYPE_Hash: case TYPE_Array:
                case TYPE_Code: case TYPE_Object:
                    write_space(fp, 4, comment_out_flag);
                    fprintf(fp, "is_deeply($ret, %s, \"%s\");\n", mtds->ret, mtds->name);
                    break;
                case TYPE_List:
                    write_space(fp, 4, comment_out_flag);
                    ((char *)mtds->ret)[0] = '[';
                    ((char *)mtds->ret)[strlen(mtds->ret) - 1] = ']';
                    fprintf(fp, "is_deeply(\\@ret, %s, \"%s\");\n", mtds->ret, mtds->name);
                    break;
                default:
                    write_space(fp, 4, comment_out_flag);
                    fprintf(fp, "ok($ret == %s, \"%s\");\n", mtds->ret, mtds->name);
                    break;
                }
            }
            fprintf(fp, "}\n");
            fprintf(fp, "\n");
            i++;
        }
        fprintf(fp, "\n");
        mtds = pkgs->mtds;
        i = 1;
        for (; mtds; mtds = mtds->next) {
            fprintf(fp, "test_%03d_%s;\n", i, mtds->subname);
            i++;
        }
        //fprintf(fp, "run_tests();\n");
        //fprintf(fp, "done_testing();\n");
        fclose(fp);
    }
}

static void TestCodeGenerator_free(TestCodeGenerator *tcg)
{
    if (tcg->pkgs) {
        tcg->pkgs->free(tcg->pkgs);
    }
    safe_free(tcg, sizeof(TestCodeGenerator));
}

TestCodeGenerator *new_TestCodeGenerator(void)
{
    TestCodeGenerator *tcg = safe_malloc(sizeof(TestCodeGenerator));
    tcg->fs = new_FastSerializer();
    tcg->getMatchedPackage = TestCodeGenerator_getMatchedPackage;
    tcg->addPackage = TestCodeGenerator_addPackage;
    tcg->gen = TestCodeGenerator_gen;
    tcg->free = TestCodeGenerator_free;
    return tcg;
}

//=====================================================================//

static OP *(*pp_return)(pTHX) = NULL;
static OP *(*pp_leavesub)(pTHX) = NULL;
static OP *(*pp_leavesublv)(pTHX) = NULL;
static OP *(*pp_goto)(pTHX) = NULL;
static OP *(*pp_entersub)(pTHX) = NULL;

//======================= FROM NYTProf ==============================//
static CV *resolve_sub_to_cv(pTHX_ SV *sv, GV **subname_gv_ptr)
{
    GV *dummy_gv;
    HV *stash;
    CV *cv;
    if (!subname_gv_ptr) {
        subname_gv_ptr = &dummy_gv;
    } else {
        *subname_gv_ptr = Nullgv;
    }
    switch (SvTYPE(sv)) {
    default:
        if (!SvROK(sv)) {
            char *sym;
            if (sv == &PL_sv_yes) {           /* unfound import, ignore */
                return NULL;
            }
            if (SvGMAGICAL(sv)) {
                mg_get(sv);
                if (SvROK(sv)) goto got_rv;
                sym = SvPOKp(sv) ? SvPVX(sv) : Nullch;
            } else {
                sym = SvPVX(sv);
            }
            if (!sym) return NULL;
            if (PL_op->op_private & HINT_STRICT_REFS) return NULL;
            cv = get_cv(sym, TRUE);
            break;
        }
    got_rv:;
        {
            SV **sp = &sv;                    /* Used in tryAMAGICunDEREF macro. */
            tryAMAGICunDEREF(to_cv);
        }
        cv = (CV*)SvRV(sv);
        if (SvTYPE(cv) == SVt_PVCV)
            break;
        /* FALL THROUGH */
    case SVt_PVHV:
    case SVt_PVAV:
        return NULL;
    case SVt_PVCV:
        cv = (CV*)sv;
        break;
    case SVt_PVGV:
        if (!(isGV_with_GP(sv) && (cv = GvCVu((GV*)sv))))
            cv = sv_2cv(sv, &stash, subname_gv_ptr, FALSE);
        if (!cv)                              /* would autoload in this situation */
            return NULL;
        break;
    }
    if (cv && !*subname_gv_ptr && CvGV(cv) && isGV_with_GP(CvGV(cv))) {
        *subname_gv_ptr = CvGV(cv);
    }
    return cv;
}

static CV* current_cv(pTHX_ I32 ix, PERL_SI *si)
{
    PERL_CONTEXT *cx;
    if (!si)
        si = PL_curstackinfo;
    if (ix < 0) {
        if (si->si_type != PERLSI_MAIN)
            return current_cv(aTHX_ si->si_prev->si_cxix, si->si_prev);
        return Nullcv;
    }
    cx = &si->si_cxstack[ix];
    if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT)
        return cx->blk_sub.cv;
    else if (CxTYPE(cx) == CXt_EVAL && !CxTRYBLOCK(cx))
        return current_cv(aTHX_ ix - 1, si);
    else if (ix == 0 && si->si_type == PERLSI_MAIN)
        return PL_main_cv;
    else if (ix > 0)
        return current_cv(aTHX_ ix - 1, si);

    if (si->si_type != PERLSI_MAIN) {
        return current_cv(aTHX_ si->si_prev->si_cxix, si->si_prev);
    }
    return Nullcv;
}

//================================================================================//
static CallFlow *cf_stack[MAX_CALLSTACK_SIZE] = {0};
static bool xs_stack[MAX_CALLSTACK_SIZE] = {0};
static char *get_serialized_argument(pTHX_ int cxix, char *caller_name, char *callee_name)
{
    const bool hasargs = (PL_op->op_flags & OPf_STACKED) != 0;
    if (hasargs) {
        int i = 0;
        AV *argarray = PL_curstackinfo->si_cxstack[cxix].cx_u.cx_blk.blk_u.blku_sub.argarray;
        if (argarray && SvTYPE(argarray) == TYPE_Array) {
            int argc = argarray->sv_any->xav_fill;//av_len((AV *)argarray);
            SV **a = argarray->sv_u.svu_array;
            if (setjmp(jbuf) == 0) {
                if (a) {
                    for (i = 0; i <= argc; i++) {
                        tcg->fs->serialize(tcg->fs, a[i]);
                        if (i != argc) {
                            write_cwb(", ");//delim
                        }
                    }
                }
            } else {
                //CHANGE_COLOR(RED);
                //fprintf(stderr, "AutoTest Exception! [TOO LARGE BUFFER SIZE]: ");
                //CHANGE_COLOR(WHITE);
                //fprintf(stderr, "%s => %s (args)\n", caller_name, callee_name);
                return NULL;
            }
        }
    }
    size_t size = strlen(cwb) + 1;
    char *args = safe_malloc(size);
    memcpy(args, cwb, size);
    //fprintf(stderr, "ARGS = [%s]\n", args);
    return args;
}

static void record_callflow(pTHX_ SV *sub_sv, OP *op)
{
    int cxix = PL_curstackinfo->si_cxix;
    int saved_errno = errno;
    OP *next_op = PL_op->op_next;
    OPCODE op_type = ((opcode) PL_op->op_type == OP_GOTO) ? (opcode) PL_op->op_type : OP_ENTERSUB;
    CV *callee_cv = NULL;
    char *callee_sub_name = NULL;
    char *caller_sub_name = NULL;
    if (op_type != OP_GOTO) {
        callee_cv = NULL;
    } else {
        //SvREFCNT_inc(sub_sv);
        callee_cv = (CV*)SvRV(sub_sv);
        SETERRNO(saved_errno, 0);
        //SvREFCNT_dec(sub_sv);
    }
    char *caller_stash_name = NULL;
    char *callee_stash_name = NULL;
    bool is_xs = false;
    if (op_type == OP_GOTO) {
        is_xs = (CvISXSUB(callee_cv)) ? true : false;
    } else {
        if (op != next_op) {
            callee_cv = cxstack[cxstack_ix].blk_sub.cv;
            is_xs = false;
        } else {
            GV *gv = NULL;
            callee_cv = resolve_sub_to_cv(aTHX_ sub_sv, &gv);
            if (!callee_cv && gv) {
                callee_stash_name = HvNAME(GvSTASH(gv));
                callee_sub_name = GvNAME(CvGV(callee_cv));
            }
            is_xs = true;
        }
    }
    xs_stack[cxix] = is_xs;
    if (callee_cv && CvGV(callee_cv)) {
        GV *gv = CvGV(callee_cv);
        if (SvTYPE(gv) == SVt_PVGV && GvSTASH(gv)) {
            callee_stash_name = HvNAME(GvSTASH(gv));
            callee_sub_name = GvNAME(CvGV(callee_cv));
        }
    }
    if (!callee_cv) {
        callee_stash_name = CopSTASHPV(PL_curcop);
    }
    CV *caller_cv = current_cv(aTHX_ cxstack_ix-1, NULL);
    if (caller_cv == PL_main_cv || !caller_cv) {
        caller_stash_name = "main";
        caller_sub_name = "main";
    } else {
        HV *stash_hv = NULL;
        GV *gv = CvGV(caller_cv);
        GV *egv = GvEGV(gv);
        if (!egv) gv = egv;
        if (gv && (stash_hv = GvSTASH(gv))) {
            caller_sub_name = GvNAME(CvGV(caller_cv));
            caller_stash_name = HvNAME(CvSTASH(caller_cv));
        }
    }
    if (!callee_sub_name) callee_sub_name = "main";
    SETERRNO(saved_errno, 0);
    if (match(caller_sub_name, "BEGIN") || match(callee_sub_name, "BEGIN") ||
        match(callee_sub_name, "export") || match(callee_sub_name, "import") ||
        match(caller_sub_name, "export") || match(caller_sub_name, "import") || is_xs) {
        return;
    }
    size_t callee_stash_size = strlen(callee_stash_name) + 1;
    size_t caller_stash_size = (caller_stash_name) ? strlen(caller_stash_name) + 1 : 0;
    size_t callee_subname_size = strlen(callee_sub_name) + 1;
    size_t caller_subname_size = (caller_sub_name) ? strlen(caller_sub_name) + 1 : 0;
    size_t callee_name_size = callee_stash_size + 2 + callee_subname_size;
    size_t caller_name_size = caller_stash_size + 2 + caller_subname_size;
    char *callee_name = (char *)safe_malloc(callee_name_size);
    char *caller_name = (char *)safe_malloc(caller_name_size);
    snprintf(callee_name, callee_name_size, "%s::%s", callee_stash_name, callee_sub_name);
    snprintf(caller_name, caller_name_size, "%s::%s", caller_stash_name, caller_sub_name);
    CallFlow *cf = new_CallFlow(caller_stash_name, caller_sub_name,
                                callee_stash_name, callee_sub_name);
    //fprintf(stderr, "stack = [%d]\n", cxix);
    //fprintf(stderr, "%s::%s => %s::%s\n", caller_name, callee_name);
    char *args = get_serialized_argument(aTHX_ cxix, caller_name, callee_name);
    cf_stack[cxix] = cf;
    Package *from_pkg = NULL;
    Package *to_pkg = NULL;
    if (!tcg->pkgs) {
        from_pkg = new_Package(caller_stash_name);
        tcg->addPackage(tcg, from_pkg);
        if (callee_stash_name && !match(caller_stash_name, callee_stash_name)) {
            to_pkg = new_Package(callee_stash_name);
            tcg->addPackage(tcg, to_pkg);
        } else {
            to_pkg = from_pkg;
        }
    } else {
        if (caller_stash_name) {
            from_pkg = tcg->getMatchedPackage(tcg, caller_stash_name);
            if (!from_pkg) {
                from_pkg = new_Package(caller_stash_name);
                tcg->addPackage(tcg, from_pkg);
            }
        }
        if (callee_stash_name) {
            to_pkg = tcg->getMatchedPackage(tcg, callee_stash_name);
            if (!to_pkg) {
                to_pkg = new_Package(callee_stash_name);
                tcg->addPackage(tcg, to_pkg);
            }
        }
    }
    Method *from_mtd = MethodList_getMatchedMethod(mtd_lists, caller_name);
    Method *to_mtd = MethodList_getMatchedMethod(mtd_lists, callee_name);
    if (!from_mtd) {
        from_mtd = new_Method(caller_name, caller_stash_name, caller_sub_name);
        from_mtd->addCallFlow(from_mtd, cf);
        MethodList_addMethod(mtd_lists, from_mtd);
        if (from_pkg) from_pkg->addMethod(from_pkg, from_mtd);
    } else {
        if (!from_mtd->existsCallFlow(from_mtd, cf)) {
            from_mtd->addCallFlow(from_mtd, cf);
        }
        //safe_free(caller_name, caller_name_size);
    }
    if (!to_mtd) {
        to_mtd = new_Method(callee_name, callee_stash_name, callee_sub_name);
        if (args) {
            to_mtd->setArgs(to_mtd, args);
        } else {
            to_mtd->args_error = true;
        }
        if (!to_mtd->ret) {
            to_mtd->ret = cf->ret;
            to_mtd->ret_type = cf->ret_type;
        }
        MethodList_addMethod(mtd_lists, to_mtd);
        if (to_pkg) {
            to_pkg->addMethod(to_pkg, to_mtd);
        }
    } else {
        if (!to_mtd->ret) {
            to_mtd->ret = cf->ret;
            to_mtd->ret_type = cf->ret_type;
        }
        if (args) {
            if (!to_mtd->args) {
                to_mtd->setArgs(to_mtd, args);
            } else {
                safe_free(args, strlen(args) + 1);
            }
        } else {
            to_mtd->args_error = true;
        }
        //safe_free(callee_name, callee_name_size);
    }
}

static void record_return_value(pTHX)
{
    int cxix = PL_curstackinfo->si_cxix;
    SV **sp = PL_stack_sp;
    int mark = *PL_markstack_ptr;
    I32 items = PL_stack_sp - PL_stack_base;
    bool is_list = false;
    CallFlow *cf = cf_stack[cxix];
    if (!cf) return;
    bool is_xs = xs_stack[cxix];
    cf->is_xs = is_xs;
    if (cf && cf->ret) return;
    if (setjmp(jbuf) == 0) {
        if (cf->from &&
            (match(cf->from, "BEGIN") ||
             match(cf->from, "export") || match(cf->from, "import") ||
             match(cf->to, "export") || match(cf->to, "import"))) {
            return;
        } else if (!sp[0] || !SvOK(sp[0])) {
            return;
        } else if (items < 0) {
            tcg->fs->serialize(tcg->fs, sp[0]);
        } else {
            int i = 0;
            I32 gimme = PL_curstackinfo->si_cxstack[cxix].cx_u.cx_blk.blku_gimme;
            int oldsp = PL_curstackinfo->si_cxstack[cxix].cx_u.cx_blk.blku_oldsp;
            mark = oldsp;
            if (gimme == G_ARRAY) {
                //fprintf(stderr, "rvalue : %s::%s => %s::%s\n", cf->from_stash, cf->from, cf->to_stash, cf->to);
                if (items > 1 + mark) {
                    is_list = true;
                    write_cwb("(");
                }
                SV **base = PL_stack_base;
                for (i = 1 + mark; i <= items; i++) {
                    if (base[i]) {
                        tcg->fs->serialize(tcg->fs, base[i]);
                    } else {
                        break;
                    }
                    if (i != items) write_cwb(", ");
                }
                if (items > 1 + mark) {
                    write_cwb(")");
                }
            } else {
                tcg->fs->serialize(tcg->fs, sp[0]);
            }
        }
    } else {
        //CHANGE_COLOR(RED);
        //fprintf(stderr, "AutoTest Exception! [TOO LARGE BUFFER SIZE]: ");
        //CHANGE_COLOR(WHITE);
        //fprintf(stderr, "%s::%s => %s::%s (rvalue)\n",
        //cf->from_stash, cf->from, cf->to_stash, cf->to);
        return;
    }
    cf->setReturnValue(cf, cwb);
    if (is_list) {
        cf->ret_type = TYPE_List;
    } else {
        cf->ret_type = (SvROK(sp[0])) ? SvTYPE(SvRV(sp[0])) : SvTYPE(sp[0]);
    }
    size_t size = strlen(cf->to_stash) + strlen(cf->to) + 4;
    char to_buf[size];
    snprintf(to_buf, size, "%s::%s", cf->to_stash, cf->to);
    Method *to_mtd = MethodList_getMatchedMethod(mtd_lists, to_buf);
    if (to_mtd && !to_mtd->ret) {
        to_mtd->ret = cf->ret;
        to_mtd->ret_type = cf->ret_type;
    }
    //fprintf(stderr, "RET = [%s]\n", cf->ret);
}

OP *hook_goto(pTHX)
{
    dSP;
    SV *sub_sv = *SP;
    OP *op = pp_goto(aTHX);
    record_callflow(aTHX_ sub_sv, op);
    memset(cwb, 0, cwb_idx);
    cwb_idx = 0;
    return op;
}

OP *hook_leavesub(pTHX)
{
    record_return_value(aTHX);
    memset(cwb, 0, cwb_idx);
    cwb_idx = 0;
    OP *op = pp_leavesub(aTHX);
    return op;
}

OP *hook_leavesublv(pTHX)
{
    record_return_value(aTHX);
    memset(cwb, 0, cwb_idx);
    cwb_idx = 0;
    OP *op = pp_leavesublv(aTHX);
    return op;
}

OP *hook_return(pTHX)
{
    record_return_value(aTHX);
    memset(cwb, 0, cwb_idx);
    cwb_idx = 0;
    OP *op = pp_return(aTHX);
    return op;
}

OP *hook_entersub(pTHX)
{
    dSP;
    SV *sub_sv = *SP;
    OP *op = pp_entersub(aTHX);
    record_callflow(aTHX_ sub_sv, op);
    memset(cwb, 0, cwb_idx);
    cwb_idx = 0;
    return op;
}


MODULE = AutoTest     PACKAGE = AutoTest
PROTOTYPES: ENABLE

void
import(klass, SV *flags = NULL)
CODE:
{
    pp_entersub = PL_ppaddr[OP_ENTERSUB];
    pp_leavesub = PL_ppaddr[OP_LEAVESUB];
    pp_leavesublv = PL_ppaddr[OP_LEAVESUBLV];
    pp_return = PL_ppaddr[OP_RETURN];
    pp_goto = PL_ppaddr[OP_GOTO];
    PL_ppaddr[OP_ENTERSUB] = hook_entersub;
    PL_ppaddr[OP_LEAVESUB] = hook_leavesub;
    PL_ppaddr[OP_LEAVESUBLV] = hook_leavesublv;
    PL_ppaddr[OP_RETURN] = hook_return;
    PL_ppaddr[OP_GOTO] = hook_goto;
    tcg = new_TestCodeGenerator();
    cwb = (char *)safe_malloc(MAX_CWB_SIZE);
}

void
END()
CODE:
{
    tcg->gen(tcg);
    PL_ppaddr[OP_ENTERSUB] = pp_entersub;
    PL_ppaddr[OP_LEAVESUB] = pp_leavesub;
	PL_ppaddr[OP_LEAVESUBLV] = pp_leavesublv;
    PL_ppaddr[OP_RETURN] = pp_return;
    PL_ppaddr[OP_GOTO] = pp_goto;
    CHANGE_COLOR(SYAN);
    fprintf(stderr, "AutoTest gen: exit normaly.\n");
    CHANGE_COLOR(WHITE);
    //tcg->free(tcg);
    //safe_free(cwb, MAX_CWB_SIZE);
    if (leaks() > 0) {
        fprintf(stderr, "memory_leaks = %d bytes\n", leaks());
    }
}

void
dump_vmcode()
CODE:
{
    OP *pc = PL_op;
    fprintf(stderr, "========= DUMP VMCODE =======\n");
    for (; pc; pc = pc->op_next) {
        fprintf(stderr, "[%s]\n", OP_NAME(pc));
    }
    fprintf(stderr, "=============================\n");
}
